diff --git a/Makefile.am b/Makefile.am
index 826c30d..65680da 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -69,6 +69,7 @@ libdrm_la_SOURCES =				\
 	xf86drmSL.c				\
 	xf86drmMode.c				\
 	xf86atomic.h				\
+	libdrm.h				\
 	libdrm_lists.h
 
 libdrmincludedir = ${includedir}
diff --git a/configure.ac b/configure.ac
index 5e9cb6c..bb0559a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -366,6 +366,26 @@ AC_ARG_WITH([kernel-source],
 	    [kernel_source="$with_kernel_source"])
 AC_SUBST(kernel_source)
 
+dnl Add flags for gcc and g++
+if test "x$GCC" = xyes; then
+    # Enable -fvisibility=hidden if using a gcc that supports it
+    save_CFLAGS="$CFLAGS"
+    AC_MSG_CHECKING([whether $CC supports -fvisibility=hidden])
+    VISIBILITY_CFLAGS="-fvisibility=hidden"
+    CFLAGS="$CFLAGS $VISIBILITY_CFLAGS"
+    AC_LINK_IFELSE([AC_LANG_PROGRAM()], AC_MSG_RESULT([yes]),
+                   [VISIBILITY_CFLAGS=""; AC_MSG_RESULT([no])]);
+
+    # Restore CFLAGS; VISIBILITY_CFLAGS are added to it where needed.
+    CFLAGS=$save_CFLAGS
+
+    if test "x$VISIBILITY_CFLAGS" != x; then
+        AC_DEFINE(HAVE_VISIBILITY, 1, [Compiler has -fvisibility support])
+    fi
+
+    AC_SUBST([VISIBILITY_CFLAGS])
+fi
+
 AC_SUBST(WARN_CFLAGS)
 AC_CONFIG_FILES([
 	Makefile
diff --git a/exynos/Makefile.am b/exynos/Makefile.am
index 0a2663a..06bee00 100644
--- a/exynos/Makefile.am
+++ b/exynos/Makefile.am
@@ -1,5 +1,6 @@
 AM_CFLAGS = \
 	$(WARN_CFLAGS) \
+	$(VISIBILITY_CFLAGS) \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/exynos \
 	$(PTHREADSTUBS_CFLAGS) \
diff --git a/exynos/exynos_drm.c b/exynos/exynos_drm.c
index 5fff259..4c7dd13 100644
--- a/exynos/exynos_drm.c
+++ b/exynos/exynos_drm.c
@@ -38,6 +38,7 @@
 
 #include <xf86drm.h>
 
+#include "libdrm.h"
 #include "exynos_drm.h"
 #include "exynos_drmif.h"
 
@@ -48,7 +49,7 @@
  *
  * if true, return the device object else NULL.
  */
-struct exynos_device * exynos_device_create(int fd)
+drm_public struct exynos_device * exynos_device_create(int fd)
 {
 	struct exynos_device *dev;
 
@@ -69,7 +70,7 @@ struct exynos_device * exynos_device_create(int fd)
  *
  * @dev: exynos drm device object.
  */
-void exynos_device_destroy(struct exynos_device *dev)
+drm_public void exynos_device_destroy(struct exynos_device *dev)
 {
 	free(dev);
 }
@@ -87,8 +88,8 @@ void exynos_device_destroy(struct exynos_device *dev)
  *
  * if true, return a exynos buffer object else NULL.
  */
-struct exynos_bo * exynos_bo_create(struct exynos_device *dev,
-						size_t size, uint32_t flags)
+drm_public struct exynos_bo * exynos_bo_create(struct exynos_device *dev,
+					       size_t size, uint32_t flags)
 {
 	struct exynos_bo *bo;
 	struct drm_exynos_gem_create req = {
@@ -141,8 +142,8 @@ fail:
  *
  * if true, return 0 else negative.
  */
-int exynos_bo_get_info(struct exynos_device *dev, uint32_t handle,
-			size_t *size, uint32_t *flags)
+drm_public int exynos_bo_get_info(struct exynos_device *dev, uint32_t handle,
+				  size_t *size, uint32_t *flags)
 {
 	int ret;
 	struct drm_exynos_gem_info req = {
@@ -167,7 +168,7 @@ int exynos_bo_get_info(struct exynos_device *dev, uint32_t handle,
  *
  * @bo: a exynos buffer object to be destroyed.
  */
-void exynos_bo_destroy(struct exynos_bo *bo)
+drm_public void exynos_bo_destroy(struct exynos_bo *bo)
 {
 	if (!bo)
 		return;
@@ -199,7 +200,8 @@ void exynos_bo_destroy(struct exynos_bo *bo)
  * if true, return a exynos buffer object else NULL.
  *
  */
-struct exynos_bo * exynos_bo_from_name(struct exynos_device *dev, uint32_t name)
+drm_public struct exynos_bo *
+exynos_bo_from_name(struct exynos_device *dev, uint32_t name)
 {
 	struct exynos_bo *bo;
 	struct drm_gem_open req = {
@@ -241,7 +243,7 @@ err_free_bo:
  *
  * if true, return 0 else negative.
  */
-int exynos_bo_get_name(struct exynos_bo *bo, uint32_t *name)
+drm_public int exynos_bo_get_name(struct exynos_bo *bo, uint32_t *name)
 {
 	if (!bo->name) {
 		struct drm_gem_flink req = {
@@ -264,7 +266,7 @@ int exynos_bo_get_name(struct exynos_bo *bo, uint32_t *name)
 	return 0;
 }
 
-uint32_t exynos_bo_handle(struct exynos_bo *bo)
+drm_public uint32_t exynos_bo_handle(struct exynos_bo *bo)
 {
 	return bo->handle;
 }
@@ -277,7 +279,7 @@ uint32_t exynos_bo_handle(struct exynos_bo *bo)
  *
  * if true, user pointer mmaped else NULL.
  */
-void *exynos_bo_map(struct exynos_bo *bo)
+drm_public void *exynos_bo_map(struct exynos_bo *bo)
 {
 	if (!bo->vaddr) {
 		struct exynos_device *dev = bo->dev;
@@ -309,8 +311,8 @@ void *exynos_bo_map(struct exynos_bo *bo)
  *
  * @return: 0 on success, -1 on error, and errno will be set
  */
-int exynos_prime_handle_to_fd(struct exynos_device *dev, uint32_t handle,
-					int *fd)
+drm_public int
+exynos_prime_handle_to_fd(struct exynos_device *dev, uint32_t handle, int *fd)
 {
 	return drmPrimeHandleToFD(dev->fd, handle, 0, fd);
 }
@@ -324,8 +326,8 @@ int exynos_prime_handle_to_fd(struct exynos_device *dev, uint32_t handle,
  *
  * @return: 0 on success, -1 on error, and errno will be set
  */
-int exynos_prime_fd_to_handle(struct exynos_device *dev, int fd,
-					uint32_t *handle)
+drm_public int
+exynos_prime_fd_to_handle(struct exynos_device *dev, int fd, uint32_t *handle)
 {
 	return drmPrimeFDToHandle(dev->fd, fd, handle);
 }
@@ -347,8 +349,9 @@ int exynos_prime_fd_to_handle(struct exynos_device *dev, int fd,
  *
  * if true, return 0 else negative.
  */
-int exynos_vidi_connection(struct exynos_device *dev, uint32_t connect,
-				uint32_t ext, void *edid)
+drm_public int
+exynos_vidi_connection(struct exynos_device *dev, uint32_t connect,
+		       uint32_t ext, void *edid)
 {
 	struct drm_exynos_vidi_connection req = {
 		.connection	= connect,
diff --git a/exynos/exynos_fimg2d.c b/exynos/exynos_fimg2d.c
index fc281b6..ce1ba1e 100644
--- a/exynos/exynos_fimg2d.c
+++ b/exynos/exynos_fimg2d.c
@@ -24,6 +24,7 @@
 
 #include <xf86drm.h>
 
+#include "libdrm.h"
 #include "exynos_drm.h"
 #include "fimg2d_reg.h"
 #include "fimg2d.h"
@@ -184,7 +185,7 @@ static int g2d_flush(struct g2d_context *ctx)
  *
  * fd: a file descriptor to drm device driver opened.
  */
-struct g2d_context *g2d_init(int fd)
+drm_public struct g2d_context *g2d_init(int fd)
 {
 	struct drm_exynos_g2d_get_ver ver;
 	struct g2d_context *ctx;
@@ -212,7 +213,7 @@ struct g2d_context *g2d_init(int fd)
 	return ctx;
 }
 
-void g2d_fini(struct g2d_context *ctx)
+drm_public void g2d_fini(struct g2d_context *ctx)
 {
 	if (ctx)
 		free(ctx);
@@ -223,7 +224,7 @@ void g2d_fini(struct g2d_context *ctx)
  *
  * @ctx: a pointer to g2d_context structure.
  */
-int g2d_exec(struct g2d_context *ctx)
+drm_public int g2d_exec(struct g2d_context *ctx)
 {
 	struct drm_exynos_g2d_exec exec;
 	int ret;
@@ -255,7 +256,8 @@ int g2d_exec(struct g2d_context *ctx)
  * @w: width value to buffer filled with given color data.
  * @h: height value to buffer filled with given color data.
  */
-int g2d_solid_fill(struct g2d_context *ctx, struct g2d_image *img,
+drm_public int
+g2d_solid_fill(struct g2d_context *ctx, struct g2d_image *img,
 			unsigned int x, unsigned int y, unsigned int w,
 			unsigned int h)
 {
@@ -315,7 +317,8 @@ int g2d_solid_fill(struct g2d_context *ctx, struct g2d_image *img,
  * @w: width value to source and destination buffers.
  * @h: height value to source and destination buffers.
  */
-int g2d_copy(struct g2d_context *ctx, struct g2d_image *src,
+drm_public int
+g2d_copy(struct g2d_context *ctx, struct g2d_image *src,
 		struct g2d_image *dst, unsigned int src_x, unsigned int src_y,
 		unsigned int dst_x, unsigned dst_y, unsigned int w,
 		unsigned int h)
@@ -414,7 +417,8 @@ int g2d_copy(struct g2d_context *ctx, struct g2d_image *src,
  * @negative: indicate that it uses color negative to source and
  *	destination buffers.
  */
-int g2d_copy_with_scale(struct g2d_context *ctx, struct g2d_image *src,
+drm_public int
+g2d_copy_with_scale(struct g2d_context *ctx, struct g2d_image *src,
 				struct g2d_image *dst, unsigned int src_x,
 				unsigned int src_y, unsigned int src_w,
 				unsigned int src_h, unsigned int dst_x,
@@ -526,7 +530,8 @@ int g2d_copy_with_scale(struct g2d_context *ctx, struct g2d_image *src,
  * @h: height value to source and destination buffer.
  * @op: blend operation type.
  */
-int g2d_blend(struct g2d_context *ctx, struct g2d_image *src,
+drm_public int
+g2d_blend(struct g2d_context *ctx, struct g2d_image *src,
 		struct g2d_image *dst, unsigned int src_x,
 		unsigned int src_y, unsigned int dst_x, unsigned int dst_y,
 		unsigned int w, unsigned int h, enum e_g2d_op op)
diff --git a/freedreno/Makefile.am b/freedreno/Makefile.am
index 7903e5b..49471e9 100644
--- a/freedreno/Makefile.am
+++ b/freedreno/Makefile.am
@@ -2,6 +2,7 @@ AUTOMAKE_OPTIONS=subdir-objects
 
 AM_CFLAGS = \
 	$(WARN_CFLAGS) \
+	$(VISIBILITY_CFLAGS) \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/freedreno \
 	$(PTHREADSTUBS_CFLAGS) \
diff --git a/freedreno/freedreno_bo.c b/freedreno/freedreno_bo.c
index 8cea4de..3a2e464 100644
--- a/freedreno/freedreno_bo.c
+++ b/freedreno/freedreno_bo.c
@@ -163,8 +163,8 @@ static struct fd_bo *find_in_bucket(struct fd_device *dev,
 }
 
 
-struct fd_bo * fd_bo_new(struct fd_device *dev,
-		uint32_t size, uint32_t flags)
+drm_public struct fd_bo *
+fd_bo_new(struct fd_device *dev, uint32_t size, uint32_t flags)
 {
 	struct fd_bo *bo = NULL;
 	struct fd_bo_bucket *bucket;
@@ -197,8 +197,8 @@ struct fd_bo * fd_bo_new(struct fd_device *dev,
 	return bo;
 }
 
-struct fd_bo *fd_bo_from_handle(struct fd_device *dev,
-		uint32_t handle, uint32_t size)
+drm_public struct fd_bo *
+fd_bo_from_handle(struct fd_device *dev, uint32_t handle, uint32_t size)
 {
 	struct fd_bo *bo = NULL;
 
@@ -209,7 +209,7 @@ struct fd_bo *fd_bo_from_handle(struct fd_device *dev,
 	return bo;
 }
 
-struct fd_bo * fd_bo_from_name(struct fd_device *dev, uint32_t name)
+drm_public struct fd_bo * fd_bo_from_name(struct fd_device *dev, uint32_t name)
 {
 	struct drm_gem_open req = {
 			.name = name,
@@ -242,13 +242,13 @@ out_unlock:
 	return bo;
 }
 
-struct fd_bo * fd_bo_ref(struct fd_bo *bo)
+drm_public struct fd_bo * fd_bo_ref(struct fd_bo *bo)
 {
 	atomic_inc(&bo->refcnt);
 	return bo;
 }
 
-void fd_bo_del(struct fd_bo *bo)
+drm_public void fd_bo_del(struct fd_bo *bo)
 {
 	struct fd_device *dev = bo->dev;
 
@@ -307,7 +307,7 @@ static void bo_del(struct fd_bo *bo)
 	bo->funcs->destroy(bo);
 }
 
-int fd_bo_get_name(struct fd_bo *bo, uint32_t *name)
+drm_public int fd_bo_get_name(struct fd_bo *bo, uint32_t *name)
 {
 	if (!bo->name) {
 		struct drm_gem_flink req = {
@@ -330,17 +330,17 @@ int fd_bo_get_name(struct fd_bo *bo, uint32_t *name)
 	return 0;
 }
 
-uint32_t fd_bo_handle(struct fd_bo *bo)
+drm_public uint32_t fd_bo_handle(struct fd_bo *bo)
 {
 	return bo->handle;
 }
 
-uint32_t fd_bo_size(struct fd_bo *bo)
+drm_public uint32_t fd_bo_size(struct fd_bo *bo)
 {
 	return bo->size;
 }
 
-void * fd_bo_map(struct fd_bo *bo)
+drm_public void * fd_bo_map(struct fd_bo *bo)
 {
 	if (!bo->map) {
 		uint64_t offset;
@@ -362,12 +362,12 @@ void * fd_bo_map(struct fd_bo *bo)
 }
 
 /* a bit odd to take the pipe as an arg, but it's a, umm, quirk of kgsl.. */
-int fd_bo_cpu_prep(struct fd_bo *bo, struct fd_pipe *pipe, uint32_t op)
+drm_public int fd_bo_cpu_prep(struct fd_bo *bo, struct fd_pipe *pipe, uint32_t op)
 {
 	return bo->funcs->cpu_prep(bo, pipe, op);
 }
 
-void fd_bo_cpu_fini(struct fd_bo *bo)
+drm_public void fd_bo_cpu_fini(struct fd_bo *bo)
 {
 	bo->funcs->cpu_fini(bo);
 }
diff --git a/freedreno/freedreno_device.c b/freedreno/freedreno_device.c
index c34963c..2d3aa33 100644
--- a/freedreno/freedreno_device.c
+++ b/freedreno/freedreno_device.c
@@ -76,7 +76,7 @@ init_cache_buckets(struct fd_device *dev)
 	}
 }
 
-struct fd_device * fd_device_new(int fd)
+drm_public struct fd_device * fd_device_new(int fd)
 {
 	struct fd_device *dev;
 	drmVersionPtr version;
@@ -115,7 +115,7 @@ struct fd_device * fd_device_new(int fd)
 /* like fd_device_new() but creates it's own private dup() of the fd
  * which is close()d when the device is finalized.
  */
-struct fd_device * fd_device_new_dup(int fd)
+drm_public struct fd_device * fd_device_new_dup(int fd)
 {
 	struct fd_device *dev = fd_device_new(dup(fd));
 	if (dev)
@@ -123,7 +123,7 @@ struct fd_device * fd_device_new_dup(int fd)
 	return dev;
 }
 
-struct fd_device * fd_device_ref(struct fd_device *dev)
+drm_public struct fd_device * fd_device_ref(struct fd_device *dev)
 {
 	atomic_inc(&dev->refcnt);
 	return dev;
@@ -146,7 +146,7 @@ void fd_device_del_locked(struct fd_device *dev)
 	fd_device_del_impl(dev);
 }
 
-void fd_device_del(struct fd_device *dev)
+drm_public void fd_device_del(struct fd_device *dev)
 {
 	if (!atomic_dec_and_test(&dev->refcnt))
 		return;
diff --git a/freedreno/freedreno_pipe.c b/freedreno/freedreno_pipe.c
index 805bf00..f55aaa4 100644
--- a/freedreno/freedreno_pipe.c
+++ b/freedreno/freedreno_pipe.c
@@ -29,7 +29,8 @@
 #include "freedreno_drmif.h"
 #include "freedreno_priv.h"
 
-struct fd_pipe * fd_pipe_new(struct fd_device *dev, enum fd_pipe_id id)
+drm_public struct fd_pipe *
+fd_pipe_new(struct fd_device *dev, enum fd_pipe_id id)
 {
 	struct fd_pipe *pipe = NULL;
 
@@ -54,18 +55,18 @@ fail:
 	return NULL;
 }
 
-void fd_pipe_del(struct fd_pipe *pipe)
+drm_public void fd_pipe_del(struct fd_pipe *pipe)
 {
 	pipe->funcs->destroy(pipe);
 }
 
-int fd_pipe_get_param(struct fd_pipe *pipe, enum fd_param_id param,
-		uint64_t *value)
+drm_public int fd_pipe_get_param(struct fd_pipe *pipe,
+				 enum fd_param_id param, uint64_t *value)
 {
 	return pipe->funcs->get_param(pipe, param, value);
 }
 
-int fd_pipe_wait(struct fd_pipe *pipe, uint32_t timestamp)
+drm_public int fd_pipe_wait(struct fd_pipe *pipe, uint32_t timestamp)
 {
 	return pipe->funcs->wait(pipe, timestamp);
 }
diff --git a/freedreno/freedreno_priv.h b/freedreno/freedreno_priv.h
index 7438485..6bd1dec 100644
--- a/freedreno/freedreno_priv.h
+++ b/freedreno/freedreno_priv.h
@@ -29,6 +29,10 @@
 #ifndef FREEDRENO_PRIV_H_
 #define FREEDRENO_PRIV_H_
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <stdlib.h>
 #include <errno.h>
 #include <string.h>
@@ -41,6 +45,7 @@
 #include <stdio.h>
 #include <assert.h>
 
+#include "libdrm.h"
 #include "xf86drm.h"
 #include "xf86atomic.h"
 
diff --git a/freedreno/freedreno_ringbuffer.c b/freedreno/freedreno_ringbuffer.c
index b9849c5..def869f 100644
--- a/freedreno/freedreno_ringbuffer.c
+++ b/freedreno/freedreno_ringbuffer.c
@@ -32,8 +32,8 @@
 #include "freedreno_priv.h"
 #include "freedreno_ringbuffer.h"
 
-struct fd_ringbuffer * fd_ringbuffer_new(struct fd_pipe *pipe,
-		uint32_t size)
+drm_public struct fd_ringbuffer *
+fd_ringbuffer_new(struct fd_pipe *pipe, uint32_t size)
 {
 	struct fd_ringbuffer *ring;
 
@@ -51,7 +51,7 @@ struct fd_ringbuffer * fd_ringbuffer_new(struct fd_pipe *pipe,
 	return ring;
 }
 
-void fd_ringbuffer_del(struct fd_ringbuffer *ring)
+drm_public void fd_ringbuffer_del(struct fd_ringbuffer *ring)
 {
 	ring->funcs->destroy(ring);
 }
@@ -60,13 +60,13 @@ void fd_ringbuffer_del(struct fd_ringbuffer *ring)
  * the IB source) as it's parent before emitting reloc's, to ensure
  * the bookkeeping works out properly.
  */
-void fd_ringbuffer_set_parent(struct fd_ringbuffer *ring,
-		struct fd_ringbuffer *parent)
+drm_public void fd_ringbuffer_set_parent(struct fd_ringbuffer *ring,
+					 struct fd_ringbuffer *parent)
 {
 	ring->parent = parent;
 }
 
-void fd_ringbuffer_reset(struct fd_ringbuffer *ring)
+drm_public void fd_ringbuffer_reset(struct fd_ringbuffer *ring)
 {
 	uint32_t *start = ring->start;
 	if (ring->pipe->id == FD_PIPE_2D)
@@ -77,30 +77,32 @@ void fd_ringbuffer_reset(struct fd_ringbuffer *ring)
 }
 
 /* maybe get rid of this and use fd_ringmarker_flush() from DDX too? */
-int fd_ringbuffer_flush(struct fd_ringbuffer *ring)
+drm_public int fd_ringbuffer_flush(struct fd_ringbuffer *ring)
 {
 	return ring->funcs->flush(ring, ring->last_start);
 }
 
-uint32_t fd_ringbuffer_timestamp(struct fd_ringbuffer *ring)
+drm_public uint32_t fd_ringbuffer_timestamp(struct fd_ringbuffer *ring)
 {
 	return ring->last_timestamp;
 }
 
-void fd_ringbuffer_reloc(struct fd_ringbuffer *ring,
-		const struct fd_reloc *reloc)
+drm_public void fd_ringbuffer_reloc(struct fd_ringbuffer *ring,
+				    const struct fd_reloc *reloc)
 {
 	ring->funcs->emit_reloc(ring, reloc);
 }
 
-void fd_ringbuffer_emit_reloc_ring(struct fd_ringbuffer *ring,
-		struct fd_ringmarker *target, struct fd_ringmarker *end)
+drm_public void
+fd_ringbuffer_emit_reloc_ring(struct fd_ringbuffer *ring,
+			      struct fd_ringmarker *target,
+			      struct fd_ringmarker *end)
 {
 	assert(target->ring == end->ring);
 	ring->funcs->emit_reloc_ring(ring, target, end);
 }
 
-struct fd_ringmarker * fd_ringmarker_new(struct fd_ringbuffer *ring)
+drm_public struct fd_ringmarker * fd_ringmarker_new(struct fd_ringbuffer *ring)
 {
 	struct fd_ringmarker *marker = NULL;
 
@@ -117,23 +119,23 @@ struct fd_ringmarker * fd_ringmarker_new(struct fd_ringbuffer *ring)
 	return marker;
 }
 
-void fd_ringmarker_del(struct fd_ringmarker *marker)
+drm_public void fd_ringmarker_del(struct fd_ringmarker *marker)
 {
 	free(marker);
 }
 
-void fd_ringmarker_mark(struct fd_ringmarker *marker)
+drm_public void fd_ringmarker_mark(struct fd_ringmarker *marker)
 {
 	marker->cur = marker->ring->cur;
 }
 
-uint32_t fd_ringmarker_dwords(struct fd_ringmarker *start,
-		struct fd_ringmarker *end)
+drm_public uint32_t fd_ringmarker_dwords(struct fd_ringmarker *start,
+					 struct fd_ringmarker *end)
 {
 	return end->cur - start->cur;
 }
 
-int fd_ringmarker_flush(struct fd_ringmarker *marker)
+drm_public int fd_ringmarker_flush(struct fd_ringmarker *marker)
 {
 	struct fd_ringbuffer *ring = marker->ring;
 	return ring->funcs->flush(ring, marker->cur);
diff --git a/freedreno/kgsl/kgsl_bo.c b/freedreno/kgsl/kgsl_bo.c
index 19a1008..c868097 100644
--- a/freedreno/kgsl/kgsl_bo.c
+++ b/freedreno/kgsl/kgsl_bo.c
@@ -171,8 +171,8 @@ struct fd_bo * kgsl_bo_from_handle(struct fd_device *dev,
 	return bo;
 }
 
-struct fd_bo * fd_bo_from_fbdev(struct fd_pipe *pipe,
-		int fbfd, uint32_t size)
+drm_public struct fd_bo *
+fd_bo_from_fbdev(struct fd_pipe *pipe, int fbfd, uint32_t size)
 {
 	struct fd_bo *bo;
 
diff --git a/intel/Makefile.am b/intel/Makefile.am
index f49b099..f734b0b 100644
--- a/intel/Makefile.am
+++ b/intel/Makefile.am
@@ -24,6 +24,7 @@
 
 AM_CFLAGS = \
 	$(WARN_CFLAGS) \
+	$(VISIBILITY_CFLAGS) \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/intel \
 	$(PTHREADSTUBS_CFLAGS) \
diff --git a/intel/intel_bufmgr.c b/intel/intel_bufmgr.c
index 905556f..03dba50 100644
--- a/intel/intel_bufmgr.c
+++ b/intel/intel_bufmgr.c
@@ -37,6 +37,7 @@
 #include <drm.h>
 #include <i915_drm.h>
 #include <pciaccess.h>
+#include "libdrm.h"
 #include "intel_bufmgr.h"
 #include "intel_bufmgr_priv.h"
 #include "xf86drm.h"
@@ -46,21 +47,21 @@
  * Convenience functions for buffer management methods.
  */
 
-drm_intel_bo *drm_intel_bo_alloc(drm_intel_bufmgr *bufmgr, const char *name,
-				 unsigned long size, unsigned int alignment)
+drm_public drm_intel_bo *
+drm_intel_bo_alloc(drm_intel_bufmgr *bufmgr, const char *name,
+		   unsigned long size, unsigned int alignment)
 {
 	return bufmgr->bo_alloc(bufmgr, name, size, alignment);
 }
 
-drm_intel_bo *drm_intel_bo_alloc_for_render(drm_intel_bufmgr *bufmgr,
-					    const char *name,
-					    unsigned long size,
-					    unsigned int alignment)
+drm_public drm_intel_bo *
+drm_intel_bo_alloc_for_render(drm_intel_bufmgr *bufmgr, const char *name,
+			      unsigned long size, unsigned int alignment)
 {
 	return bufmgr->bo_alloc_for_render(bufmgr, name, size, alignment);
 }
 
-drm_intel_bo *
+drm_public drm_intel_bo *
 drm_intel_bo_alloc_tiled(drm_intel_bufmgr *bufmgr, const char *name,
                         int x, int y, int cpp, uint32_t *tiling_mode,
                         unsigned long *pitch, unsigned long flags)
@@ -69,12 +70,14 @@ drm_intel_bo_alloc_tiled(drm_intel_bufmgr *bufmgr, const char *name,
 				      tiling_mode, pitch, flags);
 }
 
-void drm_intel_bo_reference(drm_intel_bo *bo)
+drm_public void
+drm_intel_bo_reference(drm_intel_bo *bo)
 {
 	bo->bufmgr->bo_reference(bo);
 }
 
-void drm_intel_bo_unreference(drm_intel_bo *bo)
+drm_public void
+drm_intel_bo_unreference(drm_intel_bo *bo)
 {
 	if (bo == NULL)
 		return;
@@ -82,24 +85,26 @@ void drm_intel_bo_unreference(drm_intel_bo *bo)
 	bo->bufmgr->bo_unreference(bo);
 }
 
-int drm_intel_bo_map(drm_intel_bo *buf, int write_enable)
+drm_public int
+drm_intel_bo_map(drm_intel_bo *buf, int write_enable)
 {
 	return buf->bufmgr->bo_map(buf, write_enable);
 }
 
-int drm_intel_bo_unmap(drm_intel_bo *buf)
+drm_public int
+drm_intel_bo_unmap(drm_intel_bo *buf)
 {
 	return buf->bufmgr->bo_unmap(buf);
 }
 
-int
+drm_public int
 drm_intel_bo_subdata(drm_intel_bo *bo, unsigned long offset,
 		     unsigned long size, const void *data)
 {
 	return bo->bufmgr->bo_subdata(bo, offset, size, data);
 }
 
-int
+drm_public int
 drm_intel_bo_get_subdata(drm_intel_bo *bo, unsigned long offset,
 			 unsigned long size, void *data)
 {
@@ -118,24 +123,26 @@ drm_intel_bo_get_subdata(drm_intel_bo *bo, unsigned long offset,
 	return 0;
 }
 
-void drm_intel_bo_wait_rendering(drm_intel_bo *bo)
+drm_public void
+drm_intel_bo_wait_rendering(drm_intel_bo *bo)
 {
 	bo->bufmgr->bo_wait_rendering(bo);
 }
 
-void drm_intel_bufmgr_destroy(drm_intel_bufmgr *bufmgr)
+drm_public void
+drm_intel_bufmgr_destroy(drm_intel_bufmgr *bufmgr)
 {
 	bufmgr->destroy(bufmgr);
 }
 
-int
+drm_public int
 drm_intel_bo_exec(drm_intel_bo *bo, int used,
 		  drm_clip_rect_t * cliprects, int num_cliprects, int DR4)
 {
 	return bo->bufmgr->bo_exec(bo, used, cliprects, num_cliprects, DR4);
 }
 
-int
+drm_public int
 drm_intel_bo_mrb_exec(drm_intel_bo *bo, int used,
 		drm_clip_rect_t *cliprects, int num_cliprects, int DR4,
 		unsigned int rings)
@@ -155,17 +162,20 @@ drm_intel_bo_mrb_exec(drm_intel_bo *bo, int used,
 	}
 }
 
-void drm_intel_bufmgr_set_debug(drm_intel_bufmgr *bufmgr, int enable_debug)
+drm_public void
+drm_intel_bufmgr_set_debug(drm_intel_bufmgr *bufmgr, int enable_debug)
 {
 	bufmgr->debug = enable_debug;
 }
 
-int drm_intel_bufmgr_check_aperture_space(drm_intel_bo ** bo_array, int count)
+drm_public int
+drm_intel_bufmgr_check_aperture_space(drm_intel_bo ** bo_array, int count)
 {
 	return bo_array[0]->bufmgr->check_aperture_space(bo_array, count);
 }
 
-int drm_intel_bo_flink(drm_intel_bo *bo, uint32_t * name)
+drm_public int
+drm_intel_bo_flink(drm_intel_bo *bo, uint32_t * name)
 {
 	if (bo->bufmgr->bo_flink)
 		return bo->bufmgr->bo_flink(bo, name);
@@ -173,7 +183,7 @@ int drm_intel_bo_flink(drm_intel_bo *bo, uint32_t * name)
 	return -ENODEV;
 }
 
-int
+drm_public int
 drm_intel_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 			drm_intel_bo *target_bo, uint32_t target_offset,
 			uint32_t read_domains, uint32_t write_domain)
@@ -184,7 +194,7 @@ drm_intel_bo_emit_reloc(drm_intel_bo *bo, uint32_t offset,
 }
 
 /* For fence registers, not GL fences */
-int
+drm_public int
 drm_intel_bo_emit_reloc_fence(drm_intel_bo *bo, uint32_t offset,
 			      drm_intel_bo *target_bo, uint32_t target_offset,
 			      uint32_t read_domains, uint32_t write_domain)
@@ -195,7 +205,8 @@ drm_intel_bo_emit_reloc_fence(drm_intel_bo *bo, uint32_t offset,
 }
 
 
-int drm_intel_bo_pin(drm_intel_bo *bo, uint32_t alignment)
+drm_public int
+drm_intel_bo_pin(drm_intel_bo *bo, uint32_t alignment)
 {
 	if (bo->bufmgr->bo_pin)
 		return bo->bufmgr->bo_pin(bo, alignment);
@@ -203,7 +214,8 @@ int drm_intel_bo_pin(drm_intel_bo *bo, uint32_t alignment)
 	return -ENODEV;
 }
 
-int drm_intel_bo_unpin(drm_intel_bo *bo)
+drm_public int
+drm_intel_bo_unpin(drm_intel_bo *bo)
 {
 	if (bo->bufmgr->bo_unpin)
 		return bo->bufmgr->bo_unpin(bo);
@@ -211,8 +223,9 @@ int drm_intel_bo_unpin(drm_intel_bo *bo)
 	return -ENODEV;
 }
 
-int drm_intel_bo_set_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
-			    uint32_t stride)
+drm_public int
+drm_intel_bo_set_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
+			uint32_t stride)
 {
 	if (bo->bufmgr->bo_set_tiling)
 		return bo->bufmgr->bo_set_tiling(bo, tiling_mode, stride);
@@ -221,8 +234,9 @@ int drm_intel_bo_set_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
 	return 0;
 }
 
-int drm_intel_bo_get_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
-			    uint32_t * swizzle_mode)
+drm_public int
+drm_intel_bo_get_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
+			uint32_t * swizzle_mode)
 {
 	if (bo->bufmgr->bo_get_tiling)
 		return bo->bufmgr->bo_get_tiling(bo, tiling_mode, swizzle_mode);
@@ -232,40 +246,46 @@ int drm_intel_bo_get_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
 	return 0;
 }
 
-int drm_intel_bo_disable_reuse(drm_intel_bo *bo)
+drm_public int
+drm_intel_bo_disable_reuse(drm_intel_bo *bo)
 {
 	if (bo->bufmgr->bo_disable_reuse)
 		return bo->bufmgr->bo_disable_reuse(bo);
 	return 0;
 }
 
-int drm_intel_bo_is_reusable(drm_intel_bo *bo)
+drm_public int
+drm_intel_bo_is_reusable(drm_intel_bo *bo)
 {
 	if (bo->bufmgr->bo_is_reusable)
 		return bo->bufmgr->bo_is_reusable(bo);
 	return 0;
 }
 
-int drm_intel_bo_busy(drm_intel_bo *bo)
+drm_public int
+drm_intel_bo_busy(drm_intel_bo *bo)
 {
 	if (bo->bufmgr->bo_busy)
 		return bo->bufmgr->bo_busy(bo);
 	return 0;
 }
 
-int drm_intel_bo_madvise(drm_intel_bo *bo, int madv)
+drm_public int
+drm_intel_bo_madvise(drm_intel_bo *bo, int madv)
 {
 	if (bo->bufmgr->bo_madvise)
 		return bo->bufmgr->bo_madvise(bo, madv);
 	return -1;
 }
 
-int drm_intel_bo_references(drm_intel_bo *bo, drm_intel_bo *target_bo)
+drm_public int
+drm_intel_bo_references(drm_intel_bo *bo, drm_intel_bo *target_bo)
 {
 	return bo->bufmgr->bo_references(bo, target_bo);
 }
 
-int drm_intel_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, int crtc_id)
+drm_public int
+drm_intel_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, int crtc_id)
 {
 	if (bufmgr->get_pipe_from_crtc_id)
 		return bufmgr->get_pipe_from_crtc_id(bufmgr, crtc_id);
@@ -298,9 +318,8 @@ err:
 	return size;
 }
 
-int drm_intel_get_aperture_sizes(int fd,
-				 size_t *mappable,
-				 size_t *total)
+drm_public int
+drm_intel_get_aperture_sizes(int fd, size_t *mappable, size_t *total)
 {
 
 	struct drm_i915_gem_get_aperture aperture;
diff --git a/intel/intel_bufmgr_fake.c b/intel/intel_bufmgr_fake.c
index d63fc81..c4828fa 100644
--- a/intel/intel_bufmgr_fake.c
+++ b/intel/intel_bufmgr_fake.c
@@ -49,6 +49,7 @@
 #include "drm.h"
 #include "i915_drm.h"
 #include "mm.h"
+#include "libdrm.h"
 #include "libdrm_lists.h"
 
 /* Support gcc's __FUNCTION__ for people using other compilers */
@@ -248,7 +249,7 @@ FENCE_LTE(unsigned a, unsigned b)
 	return 0;
 }
 
-void
+drm_public void
 drm_intel_bufmgr_fake_set_fence_callback(drm_intel_bufmgr *bufmgr,
 					 unsigned int (*emit) (void *priv),
 					 void (*wait) (unsigned int fence,
@@ -771,7 +772,7 @@ drm_intel_fake_bo_wait_rendering(drm_intel_bo *bo)
  *  -- just evict everything
  *  -- and wait for idle
  */
-void
+drm_public void
 drm_intel_bufmgr_fake_contended_lock_take(drm_intel_bufmgr *bufmgr)
 {
 	drm_intel_bufmgr_fake *bufmgr_fake = (drm_intel_bufmgr_fake *) bufmgr;
@@ -867,7 +868,7 @@ drm_intel_fake_bo_alloc_tiled(drm_intel_bufmgr * bufmgr,
 				       4096);
 }
 
-drm_intel_bo *
+drm_public drm_intel_bo *
 drm_intel_bo_fake_alloc_static(drm_intel_bufmgr *bufmgr,
 			       const char *name,
 			       unsigned long offset,
@@ -962,7 +963,7 @@ drm_intel_fake_bo_unreference(drm_intel_bo *bo)
  * Set the buffer as not requiring backing store, and instead get the callback
  * invoked whenever it would be set dirty.
  */
-void
+drm_public void
 drm_intel_bo_fake_disable_backing_store(drm_intel_bo *bo,
 					void (*invalidate_cb) (drm_intel_bo *bo,
 							       void *ptr),
@@ -1416,7 +1417,7 @@ drm_intel_bo_fake_post_submit(drm_intel_bo *bo)
 	bo_fake->write_domain = 0;
 }
 
-void
+drm_public void
 drm_intel_bufmgr_fake_set_exec_callback(drm_intel_bufmgr *bufmgr,
 					     int (*exec) (drm_intel_bo *bo,
 							  unsigned int used,
@@ -1539,7 +1540,8 @@ drm_intel_fake_check_aperture_space(drm_intel_bo ** bo_array, int count)
  * Used by the X Server on LeaveVT, when the card memory is no longer our
  * own.
  */
-void drm_intel_bufmgr_fake_evict_all(drm_intel_bufmgr *bufmgr)
+drm_public void
+drm_intel_bufmgr_fake_evict_all(drm_intel_bufmgr *bufmgr)
 {
 	drm_intel_bufmgr_fake *bufmgr_fake = (drm_intel_bufmgr_fake *) bufmgr;
 	struct block *block, *tmp;
@@ -1573,21 +1575,20 @@ void drm_intel_bufmgr_fake_evict_all(drm_intel_bufmgr *bufmgr)
 	pthread_mutex_unlock(&bufmgr_fake->lock);
 }
 
-void drm_intel_bufmgr_fake_set_last_dispatch(drm_intel_bufmgr *bufmgr,
-					     volatile unsigned int
-					     *last_dispatch)
+drm_public void
+drm_intel_bufmgr_fake_set_last_dispatch(drm_intel_bufmgr *bufmgr,
+					volatile unsigned int
+					*last_dispatch)
 {
 	drm_intel_bufmgr_fake *bufmgr_fake = (drm_intel_bufmgr_fake *) bufmgr;
 
 	bufmgr_fake->last_dispatch = (volatile int *)last_dispatch;
 }
 
-drm_intel_bufmgr *drm_intel_bufmgr_fake_init(int fd,
-					     unsigned long low_offset,
-					     void *low_virtual,
-					     unsigned long size,
-					     volatile unsigned int
-					     *last_dispatch)
+drm_public drm_intel_bufmgr *
+drm_intel_bufmgr_fake_init(int fd, unsigned long low_offset,
+			   void *low_virtual, unsigned long size,
+			   volatile unsigned int *last_dispatch)
 {
 	drm_intel_bufmgr_fake *bufmgr_fake;
 
diff --git a/intel/intel_bufmgr_gem.c b/intel/intel_bufmgr_gem.c
index 007a6d8..0e1cb0d 100644
--- a/intel/intel_bufmgr_gem.c
+++ b/intel/intel_bufmgr_gem.c
@@ -57,6 +57,7 @@
 #ifndef ETIME
 #define ETIME ETIMEDOUT
 #endif
+#include "libdrm.h"
 #include "libdrm_lists.h"
 #include "intel_bufmgr.h"
 #include "intel_bufmgr_priv.h"
@@ -853,7 +854,7 @@ drm_intel_gem_bo_alloc_tiled(drm_intel_bufmgr *bufmgr, const char *name,
  * This can be used when one application needs to pass a buffer object
  * to another.
  */
-drm_intel_bo *
+drm_public drm_intel_bo *
 drm_intel_bo_gem_create_from_name(drm_intel_bufmgr *bufmgr,
 				  const char *name,
 				  unsigned int handle)
@@ -1294,7 +1295,8 @@ map_gtt(drm_intel_bo *bo)
 	return 0;
 }
 
-int drm_intel_gem_bo_map_gtt(drm_intel_bo *bo)
+drm_public int
+drm_intel_gem_bo_map_gtt(drm_intel_bo *bo)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bo->bufmgr;
 	drm_intel_bo_gem *bo_gem = (drm_intel_bo_gem *) bo;
@@ -1352,7 +1354,8 @@ int drm_intel_gem_bo_map_gtt(drm_intel_bo *bo)
  * undefined).
  */
 
-int drm_intel_gem_bo_map_unsynchronized(drm_intel_bo *bo)
+drm_public int
+drm_intel_gem_bo_map_unsynchronized(drm_intel_bo *bo)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bo->bufmgr;
 #ifdef HAVE_VALGRIND
@@ -1435,7 +1438,8 @@ static int drm_intel_gem_bo_unmap(drm_intel_bo *bo)
 	return ret;
 }
 
-int drm_intel_gem_bo_unmap_gtt(drm_intel_bo *bo)
+drm_public int
+drm_intel_gem_bo_unmap_gtt(drm_intel_bo *bo)
 {
 	return drm_intel_gem_bo_unmap(bo);
 }
@@ -1550,7 +1554,8 @@ drm_intel_gem_bo_wait_rendering(drm_intel_bo *bo)
  * handle. Userspace must make sure this race does not occur if such precision
  * is important.
  */
-int drm_intel_gem_bo_wait(drm_intel_bo *bo, int64_t timeout_ns)
+drm_public int
+drm_intel_gem_bo_wait(drm_intel_bo *bo, int64_t timeout_ns)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bo->bufmgr;
 	drm_intel_bo_gem *bo_gem = (drm_intel_bo_gem *) bo;
@@ -1585,7 +1590,7 @@ int drm_intel_gem_bo_wait(drm_intel_bo *bo, int64_t timeout_ns)
  * In combination with drm_intel_gem_bo_pin() and manual fence management, we
  * can do tiled pixmaps this way.
  */
-void
+drm_public void
 drm_intel_gem_bo_start_gtt_access(drm_intel_bo *bo, int write_enable)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bo->bufmgr;
@@ -1745,7 +1750,7 @@ drm_intel_gem_bo_emit_reloc_fence(drm_intel_bo *bo, uint32_t offset,
 				read_domains, write_domain, true);
 }
 
-int
+drm_public int
 drm_intel_gem_bo_get_reloc_count(drm_intel_bo *bo)
 {
 	drm_intel_bo_gem *bo_gem = (drm_intel_bo_gem *) bo;
@@ -1766,7 +1771,7 @@ drm_intel_gem_bo_get_reloc_count(drm_intel_bo *bo)
  * Any further drm_intel_bufmgr_check_aperture_space() queries
  * involving this buffer in the tree are undefined after this call.
  */
-void
+drm_public void
 drm_intel_gem_bo_clear_relocs(drm_intel_bo *bo, int start)
 {
 	drm_intel_bo_gem *bo_gem = (drm_intel_bo_gem *) bo;
@@ -2095,7 +2100,7 @@ aub_build_dump_ringbuffer(drm_intel_bufmgr_gem *bufmgr_gem,
 	bufmgr_gem->aub_offset += 4096;
 }
 
-void
+drm_public void
 drm_intel_gem_bo_aub_dump_bmp(drm_intel_bo *bo,
 			      int x1, int y1, int width, int height,
 			      enum aub_dump_bmp_format format,
@@ -2366,7 +2371,7 @@ drm_intel_gem_bo_mrb_exec2(drm_intel_bo *bo, int used,
 			flags);
 }
 
-int
+drm_public int
 drm_intel_gem_bo_context_exec(drm_intel_bo *bo, drm_intel_context *ctx,
 			      int used, unsigned int flags)
 {
@@ -2485,7 +2490,7 @@ drm_intel_gem_bo_get_tiling(drm_intel_bo *bo, uint32_t * tiling_mode,
 	return 0;
 }
 
-drm_intel_bo *
+drm_public drm_intel_bo *
 drm_intel_bo_gem_create_from_prime(drm_intel_bufmgr *bufmgr, int prime_fd, int size)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bufmgr;
@@ -2566,7 +2571,7 @@ drm_intel_bo_gem_create_from_prime(drm_intel_bufmgr *bufmgr, int prime_fd, int s
 	return &bo_gem->bo;
 }
 
-int
+drm_public int
 drm_intel_bo_gem_export_to_prime(drm_intel_bo *bo, int *prime_fd)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bo->bufmgr;
@@ -2619,7 +2624,7 @@ drm_intel_gem_bo_flink(drm_intel_bo *bo, uint32_t * name)
  * size is only bounded by how many buffers of that size we've managed to have
  * in flight at once.
  */
-void
+drm_public void
 drm_intel_bufmgr_gem_enable_reuse(drm_intel_bufmgr *bufmgr)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *) bufmgr;
@@ -2634,7 +2639,7 @@ drm_intel_bufmgr_gem_enable_reuse(drm_intel_bufmgr *bufmgr)
  * allocation.  If this option is not enabled, all relocs will have fence
  * register allocated.
  */
-void
+drm_public void
 drm_intel_bufmgr_gem_enable_fenced_relocs(drm_intel_bufmgr *bufmgr)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *)bufmgr;
@@ -2906,7 +2911,7 @@ init_cache_buckets(drm_intel_bufmgr_gem *bufmgr_gem)
 	}
 }
 
-void
+drm_public void
 drm_intel_bufmgr_gem_set_vma_cache_size(drm_intel_bufmgr *bufmgr, int limit)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *)bufmgr;
@@ -2948,7 +2953,7 @@ get_pci_device_id(drm_intel_bufmgr_gem *bufmgr_gem)
 	return devid;
 }
 
-int
+drm_public int
 drm_intel_bufmgr_gem_get_devid(drm_intel_bufmgr *bufmgr)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *)bufmgr;
@@ -2962,7 +2967,7 @@ drm_intel_bufmgr_gem_get_devid(drm_intel_bufmgr *bufmgr)
  * This function has to be called before drm_intel_bufmgr_gem_set_aub_dump()
  * for it to have any effect.
  */
-void
+drm_public void
 drm_intel_bufmgr_gem_set_aub_filename(drm_intel_bufmgr *bufmgr,
 				      const char *filename)
 {
@@ -2981,7 +2986,7 @@ drm_intel_bufmgr_gem_set_aub_filename(drm_intel_bufmgr *bufmgr,
  * You can set up a GTT and upload your objects into the referenced
  * space, then send off batchbuffers and get BMPs out the other end.
  */
-void
+drm_public void
 drm_intel_bufmgr_gem_set_aub_dump(drm_intel_bufmgr *bufmgr, int enable)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *)bufmgr;
@@ -3037,7 +3042,7 @@ drm_intel_bufmgr_gem_set_aub_dump(drm_intel_bufmgr *bufmgr, int enable)
 	}
 }
 
-drm_intel_context *
+drm_public drm_intel_context *
 drm_intel_gem_context_create(drm_intel_bufmgr *bufmgr)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem = (drm_intel_bufmgr_gem *)bufmgr;
@@ -3064,7 +3069,7 @@ drm_intel_gem_context_create(drm_intel_bufmgr *bufmgr)
 	return context;
 }
 
-void
+drm_public void
 drm_intel_gem_context_destroy(drm_intel_context *ctx)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem;
@@ -3087,7 +3092,7 @@ drm_intel_gem_context_destroy(drm_intel_context *ctx)
 	free(ctx);
 }
 
-int
+drm_public int
 drm_intel_get_reset_stats(drm_intel_context *ctx,
 			  uint32_t *reset_count,
 			  uint32_t *active,
@@ -3121,7 +3126,7 @@ drm_intel_get_reset_stats(drm_intel_context *ctx,
 	return ret;
 }
 
-int
+drm_public int
 drm_intel_reg_read(drm_intel_bufmgr *bufmgr,
 		   uint32_t offset,
 		   uint64_t *result)
@@ -3161,7 +3166,7 @@ drm_intel_reg_read(drm_intel_bufmgr *bufmgr,
  * default state (no annotations), call this function with a \c count
  * of zero.
  */
-void
+drm_public void
 drm_intel_bufmgr_gem_set_aub_annotations(drm_intel_bo *bo,
 					 drm_intel_aub_annotation *annotations,
 					 unsigned count)
@@ -3187,7 +3192,7 @@ drm_intel_bufmgr_gem_set_aub_annotations(drm_intel_bo *bo,
  *
  * \param fd File descriptor of the opened DRM device.
  */
-drm_intel_bufmgr *
+drm_public drm_intel_bufmgr *
 drm_intel_bufmgr_gem_init(int fd, int batch_size)
 {
 	drm_intel_bufmgr_gem *bufmgr_gem;
diff --git a/intel/intel_decode.c b/intel/intel_decode.c
index 61239dd..a5d6e04 100644
--- a/intel/intel_decode.c
+++ b/intel/intel_decode.c
@@ -21,6 +21,10 @@
  * IN THE SOFTWARE.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <assert.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -29,6 +33,7 @@
 #include <stdarg.h>
 #include <string.h>
 
+#include "libdrm.h"
 #include "xf86drm.h"
 #include "intel_chipset.h"
 #include "intel_bufmgr.h"
@@ -3812,7 +3817,7 @@ decode_3d_i830(struct drm_intel_decode *ctx)
 	return 1;
 }
 
-struct drm_intel_decode *
+drm_public struct drm_intel_decode *
 drm_intel_decode_context_alloc(uint32_t devid)
 {
 	struct drm_intel_decode *ctx;
@@ -3844,20 +3849,20 @@ drm_intel_decode_context_alloc(uint32_t devid)
 	return ctx;
 }
 
-void
+drm_public void
 drm_intel_decode_context_free(struct drm_intel_decode *ctx)
 {
 	free(ctx);
 }
 
-void
+drm_public void
 drm_intel_decode_set_dump_past_end(struct drm_intel_decode *ctx,
 				   int dump_past_end)
 {
 	ctx->dump_past_end = !!dump_past_end;
 }
 
-void
+drm_public void
 drm_intel_decode_set_batch_pointer(struct drm_intel_decode *ctx,
 				   void *data, uint32_t hw_offset, int count)
 {
@@ -3866,7 +3871,7 @@ drm_intel_decode_set_batch_pointer(struct drm_intel_decode *ctx,
 	ctx->base_count = count;
 }
 
-void
+drm_public void
 drm_intel_decode_set_head_tail(struct drm_intel_decode *ctx,
 			       uint32_t head, uint32_t tail)
 {
@@ -3874,7 +3879,7 @@ drm_intel_decode_set_head_tail(struct drm_intel_decode *ctx,
 	ctx->tail = tail;
 }
 
-void
+drm_public void
 drm_intel_decode_set_output_file(struct drm_intel_decode *ctx,
 				 FILE *out)
 {
@@ -3888,7 +3893,7 @@ drm_intel_decode_set_output_file(struct drm_intel_decode *ctx,
  * \param count number of DWORDs to decode in the batch buffer
  * \param hw_offset hardware address for the buffer
  */
-void
+drm_public void
 drm_intel_decode(struct drm_intel_decode *ctx)
 {
 	int ret;
diff --git a/libdrm.h b/libdrm.h
new file mode 100644
index 0000000..23926e6
--- /dev/null
+++ b/libdrm.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright © 2014 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBDRM_LIBDRM_H
+#define LIBDRM_LIBDRM_H
+
+#if defined(HAVE_VISIBILITY)
+#  define drm_private __attribute__((visibility("hidden")))
+#  define drm_public __attribute__((visibility("default")))
+#else
+#  define drm_private
+#  define drm_public
+#endif
+
+#endif
diff --git a/nouveau/Makefile.am b/nouveau/Makefile.am
index 206e892..73cff9f 100644
--- a/nouveau/Makefile.am
+++ b/nouveau/Makefile.am
@@ -1,5 +1,6 @@
 AM_CFLAGS = \
 	$(WARN_CFLAGS) \
+	$(VISIBILITY_CFLAGS) \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/nouveau \
 	$(PTHREADSTUBS_CFLAGS) \
diff --git a/nouveau/bufctx.c b/nouveau/bufctx.c
index 23d6f09..fdd3164 100644
--- a/nouveau/bufctx.c
+++ b/nouveau/bufctx.c
@@ -68,7 +68,7 @@ nouveau_bufctx(struct nouveau_bufctx *bctx)
 	return (struct nouveau_bufctx_priv *)bctx;
 }
 
-int
+drm_public int
 nouveau_bufctx_new(struct nouveau_client *client, int bins,
 		   struct nouveau_bufctx **pbctx)
 {
@@ -88,7 +88,7 @@ nouveau_bufctx_new(struct nouveau_client *client, int bins,
 	return -ENOMEM;
 }
 
-void
+drm_public void
 nouveau_bufctx_del(struct nouveau_bufctx **pbctx)
 {
 	struct nouveau_bufctx_priv *pctx = nouveau_bufctx(*pbctx);
@@ -105,7 +105,7 @@ nouveau_bufctx_del(struct nouveau_bufctx **pbctx)
 	}
 }
 
-void
+drm_public void
 nouveau_bufctx_reset(struct nouveau_bufctx *bctx, int bin)
 {
 	struct nouveau_bufctx_priv *pctx = nouveau_bufctx(bctx);
@@ -123,7 +123,7 @@ nouveau_bufctx_reset(struct nouveau_bufctx *bctx, int bin)
 	pbin->relocs  = 0;
 }
 
-struct nouveau_bufref *
+drm_public struct nouveau_bufref *
 nouveau_bufctx_refn(struct nouveau_bufctx *bctx, int bin,
 		    struct nouveau_bo *bo, uint32_t flags)
 {
@@ -150,7 +150,7 @@ nouveau_bufctx_refn(struct nouveau_bufctx *bctx, int bin,
 	return &pref->base;
 }
 
-struct nouveau_bufref *
+drm_public struct nouveau_bufref *
 nouveau_bufctx_mthd(struct nouveau_bufctx *bctx, int bin, uint32_t packet,
 		    struct nouveau_bo *bo, uint64_t data, uint32_t flags,
 		    uint32_t vor, uint32_t tor)
diff --git a/nouveau/nouveau.c b/nouveau/nouveau.c
index 1bede84..43f0d3c 100644
--- a/nouveau/nouveau.c
+++ b/nouveau/nouveau.c
@@ -62,14 +62,14 @@ debug_init(char *args)
  * is kept here to prevent AIGLX from crashing if the DDX is linked against
  * the new libdrm, but the DRI driver against the old
  */
-int
+drm_public int
 nouveau_device_open_existing(struct nouveau_device **pdev, int close, int fd,
 			     drm_context_t ctx)
 {
 	return -EACCES;
 }
 
-int
+drm_public int
 nouveau_device_wrap(int fd, int close, struct nouveau_device **pdev)
 {
 	struct nouveau_device_priv *nvdev = calloc(1, sizeof(*nvdev));
@@ -147,7 +147,7 @@ nouveau_device_wrap(int fd, int close, struct nouveau_device **pdev)
 	return 0;
 }
 
-int
+drm_public int
 nouveau_device_open(const char *busid, struct nouveau_device **pdev)
 {
 	int ret = -ENODEV, fd = drmOpen("nouveau", busid);
@@ -159,7 +159,7 @@ nouveau_device_open(const char *busid, struct nouveau_device **pdev)
 	return ret;
 }
 
-void
+drm_public void
 nouveau_device_del(struct nouveau_device **pdev)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(*pdev);
@@ -173,7 +173,7 @@ nouveau_device_del(struct nouveau_device **pdev)
 	}
 }
 
-int
+drm_public int
 nouveau_getparam(struct nouveau_device *dev, uint64_t param, uint64_t *value)
 {
 	struct drm_nouveau_getparam r = { param, 0 };
@@ -183,14 +183,14 @@ nouveau_getparam(struct nouveau_device *dev, uint64_t param, uint64_t *value)
 	return ret;
 }
 
-int
+drm_public int
 nouveau_setparam(struct nouveau_device *dev, uint64_t param, uint64_t value)
 {
 	struct drm_nouveau_setparam r = { param, value };
 	return drmCommandWrite(dev->fd, DRM_NOUVEAU_SETPARAM, &r, sizeof(r));
 }
 
-int
+drm_public int
 nouveau_client_new(struct nouveau_device *dev, struct nouveau_client **pclient)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(dev);
@@ -229,7 +229,7 @@ unlock:
 	return ret;
 }
 
-void
+drm_public void
 nouveau_client_del(struct nouveau_client **pclient)
 {
 	struct nouveau_client_priv *pcli = nouveau_client(*pclient);
@@ -245,7 +245,7 @@ nouveau_client_del(struct nouveau_client **pclient)
 	}
 }
 
-int
+drm_public int
 nouveau_object_new(struct nouveau_object *parent, uint64_t handle,
 		   uint32_t oclass, void *data, uint32_t length,
 		   struct nouveau_object **pobj)
@@ -307,7 +307,7 @@ nouveau_object_new(struct nouveau_object *parent, uint64_t handle,
 	return 0;
 }
 
-void
+drm_public void
 nouveau_object_del(struct nouveau_object **pobj)
 {
 	struct nouveau_object *obj = *pobj;
@@ -331,7 +331,7 @@ nouveau_object_del(struct nouveau_object **pobj)
 	*pobj = NULL;
 }
 
-void *
+drm_public void *
 nouveau_object_find(struct nouveau_object *obj, uint32_t pclass)
 {
 	while (obj && obj->oclass != pclass) {
@@ -385,7 +385,7 @@ nouveau_bo_del(struct nouveau_bo *bo)
 	free(nvbo);
 }
 
-int
+drm_public int
 nouveau_bo_new(struct nouveau_device *dev, uint32_t flags, uint32_t align,
 	       uint64_t size, union nouveau_bo_config *config,
 	       struct nouveau_bo **pbo)
@@ -451,7 +451,7 @@ nouveau_bo_wrap_locked(struct nouveau_device *dev, uint32_t handle,
 	return -ENOMEM;
 }
 
-int
+drm_public int
 nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
 		struct nouveau_bo **pbo)
 {
@@ -463,7 +463,7 @@ nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
 	return ret;
 }
 
-int
+drm_public int
 nouveau_bo_name_ref(struct nouveau_device *dev, uint32_t name,
 		    struct nouveau_bo **pbo)
 {
@@ -492,7 +492,7 @@ nouveau_bo_name_ref(struct nouveau_device *dev, uint32_t name,
 	return ret;
 }
 
-int
+drm_public int
 nouveau_bo_name_get(struct nouveau_bo *bo, uint32_t *name)
 {
 	struct drm_gem_flink req = { .handle = bo->handle };
@@ -510,7 +510,7 @@ nouveau_bo_name_get(struct nouveau_bo *bo, uint32_t *name)
 	return 0;
 }
 
-void
+drm_public void
 nouveau_bo_ref(struct nouveau_bo *bo, struct nouveau_bo **pref)
 {
 	struct nouveau_bo *ref = *pref;
@@ -524,7 +524,7 @@ nouveau_bo_ref(struct nouveau_bo *bo, struct nouveau_bo **pref)
 	*pref = bo;
 }
 
-int
+drm_public int
 nouveau_bo_prime_handle_ref(struct nouveau_device *dev, int prime_fd,
 			    struct nouveau_bo **bo)
 {
@@ -553,7 +553,7 @@ nouveau_bo_prime_handle_ref(struct nouveau_device *dev, int prime_fd,
 	return ret;
 }
 
-int
+drm_public int
 nouveau_bo_set_prime(struct nouveau_bo *bo, int *prime_fd)
 {
 	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
@@ -567,7 +567,7 @@ nouveau_bo_set_prime(struct nouveau_bo *bo, int *prime_fd)
 	return 0;
 }
 
-int
+drm_public int
 nouveau_bo_wait(struct nouveau_bo *bo, uint32_t access,
 		struct nouveau_client *client)
 {
@@ -601,7 +601,7 @@ nouveau_bo_wait(struct nouveau_bo *bo, uint32_t access,
 	return ret;
 }
 
-int
+drm_public int
 nouveau_bo_map(struct nouveau_bo *bo, uint32_t access,
 	       struct nouveau_client *client)
 {
diff --git a/nouveau/private.h b/nouveau/private.h
index 4f337ad..bf9db04 100644
--- a/nouveau/private.h
+++ b/nouveau/private.h
@@ -1,6 +1,7 @@
 #ifndef __NOUVEAU_LIBDRM_PRIVATE_H__
 #define __NOUVEAU_LIBDRM_PRIVATE_H__
 
+#include <libdrm.h>
 #include <xf86drm.h>
 #include <xf86atomic.h>
 #include <pthread.h>
diff --git a/nouveau/pushbuf.c b/nouveau/pushbuf.c
index 4f77881..6e703a4 100644
--- a/nouveau/pushbuf.c
+++ b/nouveau/pushbuf.c
@@ -529,7 +529,7 @@ pushbuf_validate(struct nouveau_pushbuf *push, bool retry)
 	return ret;
 }
 
-int
+drm_public int
 nouveau_pushbuf_new(struct nouveau_client *client, struct nouveau_object *chan,
 		    int nr, uint32_t size, bool immediate,
 		    struct nouveau_pushbuf **ppush)
@@ -600,7 +600,7 @@ nouveau_pushbuf_new(struct nouveau_client *client, struct nouveau_object *chan,
 	return 0;
 }
 
-void
+drm_public void
 nouveau_pushbuf_del(struct nouveau_pushbuf **ppush)
 {
 	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(*ppush);
@@ -626,7 +626,7 @@ nouveau_pushbuf_del(struct nouveau_pushbuf **ppush)
 	*ppush = NULL;
 }
 
-struct nouveau_bufctx *
+drm_public struct nouveau_bufctx *
 nouveau_pushbuf_bufctx(struct nouveau_pushbuf *push, struct nouveau_bufctx *ctx)
 {
 	struct nouveau_bufctx *prev = push->bufctx;
@@ -634,7 +634,7 @@ nouveau_pushbuf_bufctx(struct nouveau_pushbuf *push, struct nouveau_bufctx *ctx)
 	return prev;
 }
 
-int
+drm_public int
 nouveau_pushbuf_space(struct nouveau_pushbuf *push,
 		      uint32_t dwords, uint32_t relocs, uint32_t pushes)
 {
@@ -698,7 +698,7 @@ nouveau_pushbuf_space(struct nouveau_pushbuf *push,
 	return flushed ? pushbuf_validate(push, false) : 0;
 }
 
-void
+drm_public void
 nouveau_pushbuf_data(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
 		     uint64_t offset, uint64_t length)
 {
@@ -728,14 +728,14 @@ nouveau_pushbuf_data(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
 	}
 }
 
-int
+drm_public int
 nouveau_pushbuf_refn(struct nouveau_pushbuf *push,
 		     struct nouveau_pushbuf_refn *refs, int nr)
 {
 	return pushbuf_refn(push, true, refs, nr);
 }
 
-void
+drm_public void
 nouveau_pushbuf_reloc(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
 		      uint32_t data, uint32_t flags, uint32_t vor, uint32_t tor)
 {
@@ -743,13 +743,13 @@ nouveau_pushbuf_reloc(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
 	push->cur++;
 }
 
-int
+drm_public int
 nouveau_pushbuf_validate(struct nouveau_pushbuf *push)
 {
 	return pushbuf_validate(push, true);
 }
 
-uint32_t
+drm_public uint32_t
 nouveau_pushbuf_refd(struct nouveau_pushbuf *push, struct nouveau_bo *bo)
 {
 	struct drm_nouveau_gem_pushbuf_bo *kref;
@@ -766,7 +766,7 @@ nouveau_pushbuf_refd(struct nouveau_pushbuf *push, struct nouveau_bo *bo)
 	return flags;
 }
 
-int
+drm_public int
 nouveau_pushbuf_kick(struct nouveau_pushbuf *push, struct nouveau_object *chan)
 {
 	if (!push->channel)
diff --git a/omap/Makefile.am b/omap/Makefile.am
index c77520b..0778bdd 100644
--- a/omap/Makefile.am
+++ b/omap/Makefile.am
@@ -1,5 +1,6 @@
 AM_CFLAGS = \
 	$(WARN_CFLAGS) \
+	$(VISIBILITY_CFLAGS) \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/omap \
 	$(PTHREADSTUBS_CFLAGS) \
diff --git a/omap/omap_drm.c b/omap/omap_drm.c
index 89f1491..8b4ec46 100644
--- a/omap/omap_drm.c
+++ b/omap/omap_drm.c
@@ -39,6 +39,7 @@
 #include <unistd.h>
 #include <pthread.h>
 
+#include <libdrm.h>
 #include <xf86drm.h>
 #include <xf86atomic.h>
 
@@ -91,7 +92,7 @@ static struct omap_device * omap_device_new_impl(int fd)
 	return dev;
 }
 
-struct omap_device * omap_device_new(int fd)
+drm_public struct omap_device * omap_device_new(int fd)
 {
 	struct omap_device *dev = NULL;
 
@@ -114,13 +115,13 @@ struct omap_device * omap_device_new(int fd)
 	return dev;
 }
 
-struct omap_device * omap_device_ref(struct omap_device *dev)
+drm_public struct omap_device * omap_device_ref(struct omap_device *dev)
 {
 	atomic_inc(&dev->refcnt);
 	return dev;
 }
 
-void omap_device_del(struct omap_device *dev)
+drm_public void omap_device_del(struct omap_device *dev)
 {
 	if (!atomic_dec_and_test(&dev->refcnt))
 		return;
@@ -131,7 +132,8 @@ void omap_device_del(struct omap_device *dev)
 	free(dev);
 }
 
-int omap_get_param(struct omap_device *dev, uint64_t param, uint64_t *value)
+drm_public int
+omap_get_param(struct omap_device *dev, uint64_t param, uint64_t *value)
 {
 	struct drm_omap_param req = {
 			.param = param,
@@ -148,7 +150,8 @@ int omap_get_param(struct omap_device *dev, uint64_t param, uint64_t *value)
 	return 0;
 }
 
-int omap_set_param(struct omap_device *dev, uint64_t param, uint64_t value)
+drm_public int
+omap_set_param(struct omap_device *dev, uint64_t param, uint64_t value)
 {
 	struct drm_omap_param req = {
 			.param = param,
@@ -226,8 +229,8 @@ fail:
 
 
 /* allocate a new (un-tiled) buffer object */
-struct omap_bo * omap_bo_new(struct omap_device *dev,
-		uint32_t size, uint32_t flags)
+drm_public struct omap_bo *
+omap_bo_new(struct omap_device *dev, uint32_t size, uint32_t flags)
 {
 	union omap_gem_size gsize = {
 			.bytes = size,
@@ -239,8 +242,9 @@ struct omap_bo * omap_bo_new(struct omap_device *dev,
 }
 
 /* allocate a new buffer object */
-struct omap_bo * omap_bo_new_tiled(struct omap_device *dev,
-		uint32_t width, uint32_t height, uint32_t flags)
+drm_public struct omap_bo *
+omap_bo_new_tiled(struct omap_device *dev, uint32_t width,
+		  uint32_t height, uint32_t flags)
 {
 	union omap_gem_size gsize = {
 			.tiled = {
@@ -254,7 +258,7 @@ struct omap_bo * omap_bo_new_tiled(struct omap_device *dev,
 	return omap_bo_new_impl(dev, gsize, flags);
 }
 
-struct omap_bo * omap_bo_ref(struct omap_bo *bo)
+drm_public struct omap_bo *omap_bo_ref(struct omap_bo *bo)
 {
 	atomic_inc(&bo->refcnt);
 	return bo;
@@ -280,7 +284,8 @@ static int get_buffer_info(struct omap_bo *bo)
 }
 
 /* import a buffer object from DRI2 name */
-struct omap_bo * omap_bo_from_name(struct omap_device *dev, uint32_t name)
+drm_public struct omap_bo *
+omap_bo_from_name(struct omap_device *dev, uint32_t name)
 {
 	struct omap_bo *bo = NULL;
 	struct drm_gem_open req = {
@@ -313,7 +318,8 @@ fail:
  * fd so caller should close() the fd when it is otherwise done
  * with it (even if it is still using the 'struct omap_bo *')
  */
-struct omap_bo * omap_bo_from_dmabuf(struct omap_device *dev, int fd)
+drm_public struct omap_bo *
+omap_bo_from_dmabuf(struct omap_device *dev, int fd)
 {
 	struct omap_bo *bo = NULL;
 	struct drm_prime_handle req = {
@@ -344,7 +350,7 @@ fail:
 }
 
 /* destroy a buffer object */
-void omap_bo_del(struct omap_bo *bo)
+drm_public void omap_bo_del(struct omap_bo *bo)
 {
 	if (!bo) {
 		return;
@@ -377,7 +383,7 @@ void omap_bo_del(struct omap_bo *bo)
 }
 
 /* get the global flink/DRI2 buffer name */
-int omap_bo_get_name(struct omap_bo *bo, uint32_t *name)
+drm_public int omap_bo_get_name(struct omap_bo *bo, uint32_t *name)
 {
 	if (!bo->name) {
 		struct drm_gem_flink req = {
@@ -398,7 +404,7 @@ int omap_bo_get_name(struct omap_bo *bo, uint32_t *name)
 	return 0;
 }
 
-uint32_t omap_bo_handle(struct omap_bo *bo)
+drm_public uint32_t omap_bo_handle(struct omap_bo *bo)
 {
 	return bo->handle;
 }
@@ -406,7 +412,7 @@ uint32_t omap_bo_handle(struct omap_bo *bo)
 /* caller owns the dmabuf fd that is returned and is responsible
  * to close() it when done
  */
-int omap_bo_dmabuf(struct omap_bo *bo)
+drm_public int omap_bo_dmabuf(struct omap_bo *bo)
 {
 	if (!bo->fd) {
 		struct drm_prime_handle req = {
@@ -425,7 +431,7 @@ int omap_bo_dmabuf(struct omap_bo *bo)
 	return dup(bo->fd);
 }
 
-uint32_t omap_bo_size(struct omap_bo *bo)
+drm_public uint32_t omap_bo_size(struct omap_bo *bo)
 {
 	if (!bo->size) {
 		get_buffer_info(bo);
@@ -433,7 +439,7 @@ uint32_t omap_bo_size(struct omap_bo *bo)
 	return bo->size;
 }
 
-void * omap_bo_map(struct omap_bo *bo)
+drm_public void *omap_bo_map(struct omap_bo *bo)
 {
 	if (!bo->map) {
 		if (!bo->offset) {
@@ -449,7 +455,7 @@ void * omap_bo_map(struct omap_bo *bo)
 	return bo->map;
 }
 
-int omap_bo_cpu_prep(struct omap_bo *bo, enum omap_gem_op op)
+drm_public int omap_bo_cpu_prep(struct omap_bo *bo, enum omap_gem_op op)
 {
 	struct drm_omap_gem_cpu_prep req = {
 			.handle = bo->handle,
@@ -459,7 +465,7 @@ int omap_bo_cpu_prep(struct omap_bo *bo, enum omap_gem_op op)
 			DRM_OMAP_GEM_CPU_PREP, &req, sizeof(req));
 }
 
-int omap_bo_cpu_fini(struct omap_bo *bo, enum omap_gem_op op)
+drm_public int omap_bo_cpu_fini(struct omap_bo *bo, enum omap_gem_op op)
 {
 	struct drm_omap_gem_cpu_fini req = {
 			.handle = bo->handle,
diff --git a/radeon/Makefile.am b/radeon/Makefile.am
index a8cd100..c969573 100644
--- a/radeon/Makefile.am
+++ b/radeon/Makefile.am
@@ -24,6 +24,7 @@
 
 AM_CFLAGS = \
 	$(WARN_CFLAGS) \
+	$(VISIBILITY_CFLAGS) \
 	-I$(top_srcdir) \
 	-I$(top_srcdir)/radeon \
 	$(PTHREADSTUBS_CFLAGS) \
diff --git a/radeon/radeon_bo.c b/radeon/radeon_bo.c
index 6a0f8e7..865e3f7 100644
--- a/radeon/radeon_bo.c
+++ b/radeon/radeon_bo.c
@@ -29,10 +29,14 @@
  *      Dave Airlie
  *      Jérôme Glisse <glisse@freedesktop.org>
  */
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <libdrm.h>
 #include <radeon_bo.h>
 #include <radeon_bo_int.h>
 
-void radeon_bo_debug(struct radeon_bo *bo, const char *op)
+drm_public void radeon_bo_debug(struct radeon_bo *bo, const char *op)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
 
@@ -40,26 +44,23 @@ void radeon_bo_debug(struct radeon_bo *bo, const char *op)
             op, bo, bo->handle, boi->size, boi->cref);
 }
 
-struct radeon_bo *radeon_bo_open(struct radeon_bo_manager *bom,
-                                 uint32_t handle,
-                                 uint32_t size,
-                                 uint32_t alignment,
-                                 uint32_t domains,
-                                 uint32_t flags)
+drm_public struct radeon_bo *
+radeon_bo_open(struct radeon_bo_manager *bom, uint32_t handle, uint32_t size,
+	       uint32_t alignment, uint32_t domains, uint32_t flags)
 {
     struct radeon_bo *bo;
     bo = bom->funcs->bo_open(bom, handle, size, alignment, domains, flags);
     return bo;
 }
 
-void radeon_bo_ref(struct radeon_bo *bo)
+drm_public void radeon_bo_ref(struct radeon_bo *bo)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     boi->cref++;
     boi->bom->funcs->bo_ref(boi);
 }
 
-struct radeon_bo *radeon_bo_unref(struct radeon_bo *bo)
+drm_public struct radeon_bo *radeon_bo_unref(struct radeon_bo *bo)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     if (bo == NULL)
@@ -69,19 +70,19 @@ struct radeon_bo *radeon_bo_unref(struct radeon_bo *bo)
     return boi->bom->funcs->bo_unref(boi);
 }
 
-int radeon_bo_map(struct radeon_bo *bo, int write)
+drm_public int radeon_bo_map(struct radeon_bo *bo, int write)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     return boi->bom->funcs->bo_map(boi, write);
 }
 
-int radeon_bo_unmap(struct radeon_bo *bo)
+drm_public int radeon_bo_unmap(struct radeon_bo *bo)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     return boi->bom->funcs->bo_unmap(boi);
 }
 
-int radeon_bo_wait(struct radeon_bo *bo)
+drm_public int radeon_bo_wait(struct radeon_bo *bo)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     if (!boi->bom->funcs->bo_wait)
@@ -89,27 +90,29 @@ int radeon_bo_wait(struct radeon_bo *bo)
     return boi->bom->funcs->bo_wait(boi);
 }
 
-int radeon_bo_is_busy(struct radeon_bo *bo, uint32_t *domain)
+drm_public int radeon_bo_is_busy(struct radeon_bo *bo, uint32_t *domain)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     return boi->bom->funcs->bo_is_busy(boi, domain);
 }
 
-int radeon_bo_set_tiling(struct radeon_bo *bo,
-                         uint32_t tiling_flags, uint32_t pitch)
+drm_public int
+radeon_bo_set_tiling(struct radeon_bo *bo,
+                     uint32_t tiling_flags, uint32_t pitch)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     return boi->bom->funcs->bo_set_tiling(boi, tiling_flags, pitch);
 }
 
-int radeon_bo_get_tiling(struct radeon_bo *bo,
-                         uint32_t *tiling_flags, uint32_t *pitch)
+drm_public int
+radeon_bo_get_tiling(struct radeon_bo *bo,
+                     uint32_t *tiling_flags, uint32_t *pitch)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     return boi->bom->funcs->bo_get_tiling(boi, tiling_flags, pitch);
 }
 
-int radeon_bo_is_static(struct radeon_bo *bo)
+drm_public int radeon_bo_is_static(struct radeon_bo *bo)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     if (boi->bom->funcs->bo_is_static)
@@ -117,18 +120,19 @@ int radeon_bo_is_static(struct radeon_bo *bo)
     return 0;
 }
 
-int radeon_bo_is_referenced_by_cs(struct radeon_bo *bo, struct radeon_cs *cs)
+drm_public int
+radeon_bo_is_referenced_by_cs(struct radeon_bo *bo, struct radeon_cs *cs)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     return boi->cref > 1;
 }
 
-uint32_t radeon_bo_get_handle(struct radeon_bo *bo)
+drm_public uint32_t radeon_bo_get_handle(struct radeon_bo *bo)
 {
     return bo->handle;
 }
 
-uint32_t radeon_bo_get_src_domain(struct radeon_bo *bo)
+drm_public uint32_t radeon_bo_get_src_domain(struct radeon_bo *bo)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     uint32_t src_domain;
diff --git a/radeon/radeon_bo_gem.c b/radeon/radeon_bo_gem.c
index 4ea405f..251ec1b 100644
--- a/radeon/radeon_bo_gem.c
+++ b/radeon/radeon_bo_gem.c
@@ -38,6 +38,7 @@
 #include <string.h>
 #include <sys/mman.h>
 #include <errno.h>
+#include "libdrm.h"
 #include "xf86drm.h"
 #include "xf86atomic.h"
 #include "drm.h"
@@ -283,7 +284,7 @@ static struct radeon_bo_funcs bo_gem_funcs = {
     bo_is_busy,
 };
 
-struct radeon_bo_manager *radeon_bo_manager_gem_ctor(int fd)
+drm_public struct radeon_bo_manager *radeon_bo_manager_gem_ctor(int fd)
 {
     struct bo_manager_gem *bomg;
 
@@ -296,7 +297,7 @@ struct radeon_bo_manager *radeon_bo_manager_gem_ctor(int fd)
     return (struct radeon_bo_manager*)bomg;
 }
 
-void radeon_bo_manager_gem_dtor(struct radeon_bo_manager *bom)
+drm_public void radeon_bo_manager_gem_dtor(struct radeon_bo_manager *bom)
 {
     struct bo_manager_gem *bomg = (struct bo_manager_gem*)bom;
 
@@ -306,19 +307,22 @@ void radeon_bo_manager_gem_dtor(struct radeon_bo_manager *bom)
     free(bomg);
 }
 
-uint32_t radeon_gem_name_bo(struct radeon_bo *bo)
+drm_public uint32_t
+radeon_gem_name_bo(struct radeon_bo *bo)
 {
     struct radeon_bo_gem *bo_gem = (struct radeon_bo_gem*)bo;
     return bo_gem->name;
 }
 
-void *radeon_gem_get_reloc_in_cs(struct radeon_bo *bo)
+drm_public void *
+radeon_gem_get_reloc_in_cs(struct radeon_bo *bo)
 {
     struct radeon_bo_gem *bo_gem = (struct radeon_bo_gem*)bo;
     return &bo_gem->reloc_in_cs;
 }
 
-int radeon_gem_get_kernel_name(struct radeon_bo *bo, uint32_t *name)
+drm_public int
+radeon_gem_get_kernel_name(struct radeon_bo *bo, uint32_t *name)
 {
     struct radeon_bo_gem *bo_gem = (struct radeon_bo_gem*)bo;
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
@@ -339,7 +343,8 @@ int radeon_gem_get_kernel_name(struct radeon_bo *bo, uint32_t *name)
     return 0;
 }
 
-int radeon_gem_set_domain(struct radeon_bo *bo, uint32_t read_domains, uint32_t write_domain)
+drm_public int
+radeon_gem_set_domain(struct radeon_bo *bo, uint32_t read_domains, uint32_t write_domain)
 {
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
     struct drm_radeon_gem_set_domain args;
@@ -356,7 +361,7 @@ int radeon_gem_set_domain(struct radeon_bo *bo, uint32_t read_domains, uint32_t
     return r;
 }
 
-int radeon_gem_prime_share_bo(struct radeon_bo *bo, int *handle)
+drm_public int radeon_gem_prime_share_bo(struct radeon_bo *bo, int *handle)
 {
     struct radeon_bo_gem *bo_gem = (struct radeon_bo_gem*)bo;
     int ret;
@@ -365,9 +370,8 @@ int radeon_gem_prime_share_bo(struct radeon_bo *bo, int *handle)
     return ret;
 }
 
-struct radeon_bo *radeon_gem_bo_open_prime(struct radeon_bo_manager *bom,
-					   int fd_handle,
-					   uint32_t size)
+drm_public struct radeon_bo *
+radeon_gem_bo_open_prime(struct radeon_bo_manager *bom, int fd_handle, uint32_t size)
 {
     struct radeon_bo_gem *bo;
     int r;
diff --git a/radeon/radeon_cs.c b/radeon/radeon_cs.c
index d0e922b..fe5bbce 100644
--- a/radeon/radeon_cs.c
+++ b/radeon/radeon_cs.c
@@ -1,19 +1,22 @@
-
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include "libdrm.h"
 #include <stdio.h>
 #include "radeon_cs.h"
 #include "radeon_cs_int.h"
 
-struct radeon_cs *radeon_cs_create(struct radeon_cs_manager *csm, uint32_t ndw)
+drm_public struct radeon_cs *
+radeon_cs_create(struct radeon_cs_manager *csm, uint32_t ndw)
 {
     struct radeon_cs_int *csi = csm->funcs->cs_create(csm, ndw);
     return (struct radeon_cs *)csi;
 }
 
-int radeon_cs_write_reloc(struct radeon_cs *cs,
-                          struct radeon_bo *bo,
-                          uint32_t read_domain,
-                          uint32_t write_domain,
-                          uint32_t flags)
+drm_public int
+radeon_cs_write_reloc(struct radeon_cs *cs, struct radeon_bo *bo,
+                      uint32_t read_domain, uint32_t write_domain,
+                      uint32_t flags)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
 
@@ -24,56 +27,54 @@ int radeon_cs_write_reloc(struct radeon_cs *cs,
                                            flags);
 }
 
-int radeon_cs_begin(struct radeon_cs *cs,
-                    uint32_t ndw,
-                    const char *file,
-                    const char *func,
-                    int line)
+drm_public int
+radeon_cs_begin(struct radeon_cs *cs, uint32_t ndw,
+                const char *file, const char *func, int line)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return csi->csm->funcs->cs_begin(csi, ndw, file, func, line);
 }
 
-int radeon_cs_end(struct radeon_cs *cs,
-                  const char *file,
-                  const char *func,
-                  int line)
+drm_public int
+radeon_cs_end(struct radeon_cs *cs,
+              const char *file, const char *func, int line)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return csi->csm->funcs->cs_end(csi, file, func, line);
 }
 
-int radeon_cs_emit(struct radeon_cs *cs)
+drm_public int radeon_cs_emit(struct radeon_cs *cs)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return csi->csm->funcs->cs_emit(csi);
 }
 
-int radeon_cs_destroy(struct radeon_cs *cs)
+drm_public int radeon_cs_destroy(struct radeon_cs *cs)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return csi->csm->funcs->cs_destroy(csi);
 }
 
-int radeon_cs_erase(struct radeon_cs *cs)
+drm_public int radeon_cs_erase(struct radeon_cs *cs)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return csi->csm->funcs->cs_erase(csi);
 }
 
-int radeon_cs_need_flush(struct radeon_cs *cs)
+drm_public int radeon_cs_need_flush(struct radeon_cs *cs)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return csi->csm->funcs->cs_need_flush(csi);
 }
 
-void radeon_cs_print(struct radeon_cs *cs, FILE *file)
+drm_public void radeon_cs_print(struct radeon_cs *cs, FILE *file)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     csi->csm->funcs->cs_print(csi, file);
 }
 
-void radeon_cs_set_limit(struct radeon_cs *cs, uint32_t domain, uint32_t limit)
+drm_public void
+radeon_cs_set_limit(struct radeon_cs *cs, uint32_t domain, uint32_t limit)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     if (domain == RADEON_GEM_DOMAIN_VRAM)
@@ -82,14 +83,15 @@ void radeon_cs_set_limit(struct radeon_cs *cs, uint32_t domain, uint32_t limit)
         csi->csm->gart_limit = limit;
 }
 
-void radeon_cs_space_set_flush(struct radeon_cs *cs, void (*fn)(void *), void *data)
+drm_public void radeon_cs_space_set_flush(struct radeon_cs *cs, 
+                                          void (*fn)(void *), void *data)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     csi->space_flush_fn = fn;
     csi->space_flush_data = data;
 }
 
-uint32_t radeon_cs_get_id(struct radeon_cs *cs)
+drm_public uint32_t radeon_cs_get_id(struct radeon_cs *cs)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return csi->id;
diff --git a/radeon/radeon_cs_gem.c b/radeon/radeon_cs_gem.c
index b87c6b1..2020e1a 100644
--- a/radeon/radeon_cs_gem.c
+++ b/radeon/radeon_cs_gem.c
@@ -29,6 +29,9 @@
  *      Nicolai Haehnle <prefect_@gmx.net>
  *      Jérôme Glisse <glisse@freedesktop.org>
  */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
 #include <assert.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -42,6 +45,7 @@
 #include "radeon_cs_gem.h"
 #include "radeon_bo_gem.h"
 #include "drm.h"
+#include "libdrm.h"
 #include "xf86drm.h"
 #include "xf86atomic.h"
 #include "radeon_drm.h"
@@ -533,7 +537,7 @@ static int radeon_get_device_id(int fd, uint32_t *device_id)
     return r;
 }
 
-struct radeon_cs_manager *radeon_cs_manager_gem_ctor(int fd)
+drm_public struct radeon_cs_manager *radeon_cs_manager_gem_ctor(int fd)
 {
     struct radeon_cs_manager_gem *csm;
 
@@ -547,7 +551,7 @@ struct radeon_cs_manager *radeon_cs_manager_gem_ctor(int fd)
     return &csm->base;
 }
 
-void radeon_cs_manager_gem_dtor(struct radeon_cs_manager *csm)
+drm_public void radeon_cs_manager_gem_dtor(struct radeon_cs_manager *csm)
 {
     free(csm);
 }
diff --git a/radeon/radeon_cs_space.c b/radeon/radeon_cs_space.c
index be047a7..cca650b 100644
--- a/radeon/radeon_cs_space.c
+++ b/radeon/radeon_cs_space.c
@@ -25,9 +25,13 @@
  */
 /*
  */
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 #include <assert.h>
 #include <errno.h>
 #include <stdlib.h>
+#include "libdrm.h"
 #include "radeon_cs.h"
 #include "radeon_bo_int.h"
 #include "radeon_cs_int.h"
@@ -161,7 +165,9 @@ static int radeon_cs_do_space_check(struct radeon_cs_int *cs, struct radeon_cs_s
     return RADEON_CS_SPACE_OK;
 }
 
-void radeon_cs_space_add_persistent_bo(struct radeon_cs *cs, struct radeon_bo *bo, uint32_t read_domains, uint32_t write_domain)
+drm_public void
+radeon_cs_space_add_persistent_bo(struct radeon_cs *cs, struct radeon_bo *bo,
+                                  uint32_t read_domains, uint32_t write_domain)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
@@ -203,9 +209,9 @@ again:
     return 0;
 }
 
-int radeon_cs_space_check_with_bo(struct radeon_cs *cs,
-                  struct radeon_bo *bo,
-                  uint32_t read_domains, uint32_t write_domain)
+drm_public int
+radeon_cs_space_check_with_bo(struct radeon_cs *cs, struct radeon_bo *bo,
+                              uint32_t read_domains, uint32_t write_domain)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     struct radeon_bo_int *boi = (struct radeon_bo_int *)bo;
@@ -224,13 +230,13 @@ int radeon_cs_space_check_with_bo(struct radeon_cs *cs,
     return ret;
 }
 
-int radeon_cs_space_check(struct radeon_cs *cs)
+drm_public int radeon_cs_space_check(struct radeon_cs *cs)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     return radeon_cs_check_space_internal(csi, NULL);
 }
 
-void radeon_cs_space_reset_bos(struct radeon_cs *cs)
+drm_public void radeon_cs_space_reset_bos(struct radeon_cs *cs)
 {
     struct radeon_cs_int *csi = (struct radeon_cs_int *)cs;
     int i;
diff --git a/radeon/radeon_surface.c b/radeon/radeon_surface.c
index 8a1fe7d..e056ed4 100644
--- a/radeon/radeon_surface.c
+++ b/radeon/radeon_surface.c
@@ -26,6 +26,9 @@
  * Authors:
  *      Jérôme Glisse <jglisse@redhat.com>
  */
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 #include <stdbool.h>
 #include <assert.h>
 #include <errno.h>
@@ -35,6 +38,7 @@
 #include <sys/mman.h>
 #include <sys/ioctl.h>
 #include "drm.h"
+#include "libdrm.h"
 #include "xf86drm.h"
 #include "radeon_drm.h"
 #include "radeon_surface.h"
@@ -2395,7 +2399,8 @@ static int cik_surface_best(struct radeon_surface_manager *surf_man,
 /* ===========================================================================
  * public API
  */
-struct radeon_surface_manager *radeon_surface_manager_new(int fd)
+drm_public struct radeon_surface_manager *
+radeon_surface_manager_new(int fd)
 {
     struct radeon_surface_manager *surf_man;
 
@@ -2443,7 +2448,8 @@ out_err:
     return NULL;
 }
 
-void radeon_surface_manager_free(struct radeon_surface_manager *surf_man)
+drm_public void
+radeon_surface_manager_free(struct radeon_surface_manager *surf_man)
 {
     free(surf_man);
 }
@@ -2515,8 +2521,9 @@ static int radeon_surface_sanity(struct radeon_surface_manager *surf_man,
     return 0;
 }
 
-int radeon_surface_init(struct radeon_surface_manager *surf_man,
-                        struct radeon_surface *surf)
+drm_public int
+radeon_surface_init(struct radeon_surface_manager *surf_man,
+                    struct radeon_surface *surf)
 {
     unsigned mode, type;
     int r;
@@ -2531,8 +2538,9 @@ int radeon_surface_init(struct radeon_surface_manager *surf_man,
     return surf_man->surface_init(surf_man, surf);
 }
 
-int radeon_surface_best(struct radeon_surface_manager *surf_man,
-                        struct radeon_surface *surf)
+drm_public int
+radeon_surface_best(struct radeon_surface_manager *surf_man,
+                    struct radeon_surface *surf)
 {
     unsigned mode, type;
     int r;
